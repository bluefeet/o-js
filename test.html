<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>o.js Unit Tests</title>
        <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.11.0.css">
    </head>
    <body>

<div id="qunit"></div>
<div id="qunit-fixture"></div>

<script src="http://code.jquery.com/qunit/qunit-1.11.0.js"></script>

<script>var o = 'ORIGINAL_O';</script>
<script src="o.js"></script>
<script src="o-types.js"></script>
<script src="o-attribute.js"></script>

<script>
test( 'core: reader', function () {
    // basics
    var obj = { getName: o.reader('name') };
    equal( obj.getName(), undefined, 'property is undefined' );
    obj.name = 'foo';
    equal( obj.getName(), 'foo', 'property was read' );

    // predicate
    var hasAge = o.predicate('age');
    var predicateCalled = false;
    obj.getAge = o.reader('age', {
        predicate: function () { predicateCalled = true; return hasAge.call(this) },
    });
    equal( obj.getAge(), undefined, 'property is undefeind with predicate set' );
    ok( predicateCalled, 'the custom predicate was called' );
    obj.age = 18;
    equal( obj.getAge(), 18, 'property was read with predicate set' );

    // required
    obj.getColor = o.reader('color', { required: true });
    throws( function(){ obj.getColor() }, 'throws when required' );
    obj.color = 'blue';
    equal( obj.getColor(), 'blue', 'property was read with required set' );

    // devoid (value)
    obj.getHeight = o.reader('height', {devoid:183});
    equal( obj.getHeight(), 183, 'value devoid was applied' );
    obj.height = 168;
    equal( obj.getHeight(), 168, 'value devoid was bypassed by explicit value' );

    // devoid (function)
    obj.getWeight = o.reader('weight', {devoid: function(){ return 90 }});
    equal( obj.getWeight(), 90, 'function devoid was applied' );
    obj.weight = 68;
    equal( obj.getWeight(), 68, 'function devoid was bypassed by explicit value' );

    // devoid function that returns a function
    obj.getHook = o.reader('hook', {devoid: function(){ return function(){ return 'hook!' } }});
    equal( obj.getHook()(), 'hook!', 'devoid can return a function' );

    // devoid and required precedence
    obj.getPoints = o.reader('points', {required:true, devoid:25});
    throws( function(){ obj.getPoints() }, 'required is evaluated before devoid' );

    // writer
    var setLevel = o.writer('level');
    var writerCalled = false;
    obj.getLevel = o.reader('level', {
        writer: function () { writerCalled = true; return setLevel.apply(this, arguments) },
        devoid: 6
    });
    equal( obj.getLevel(), 6, 'devoid was set with writer set' );
    ok( writerCalled, 'the custom writer was called' );
});

test( 'core: writer', function () {
    // basics
    var obj = { setName: o.writer('name') };
    equal( obj.name, undefined, 'property started as undefined' );
    equal( obj.setName( 'bar' ), 'bar', 'written value is returned' );
    equal( obj.name, 'bar', 'property was set' );

    // type (typeof)
    obj.setAge = o.writer('age', {type:'number'});
    throws( function(){ obj.setAge('abc') }, 'string does not pass typeof number check' );
    obj.setAge(24);
    equal( obj.age, 24, 'number passes typeof number check' );

    // type (function)
    obj.setColor = o.writer('color', {type: function(val){ return (typeof val === 'string') ? true : false }});
    throws( function(){ obj.setColor(123) }, 'number does not pass function string check' );
    obj.setColor('green');
    equal( obj.color, 'green', 'string passes function string check' );

    // chain
    obj.setLevel = o.writer('level', {chain:true});
    equal( obj.setLevel(32), obj, 'chain returned context' );
    equal( obj.level, 32, 'property was set with chain' );

    // filter
    obj.setPoints = o.writer('points', {filter:function(val){ return val+1 }, type:function(val){ return (val>=0) ? true : false }});
    equal( obj.setPoints(-1), 0, 'filter filtered' );
    throws( function(){ obj.setPoints(-2) }, 'type was applied to filtered value' );

    // augments
    var A = function () { };
    var B = function () { };
    obj.setThing = o.writer('thing', {augments:A});
    ok( obj.setThing(new A()), 'passed augments check' );
    throws( function(){ obj.setThing(new B()) }, 'augments check failed' );
});

test( 'core: accessor', function () {
    // basics
    var obj = { name: o.accessor('_name') };
    equal( obj._name, undefined, 'property started as undefined' );
    equal( obj.name( 'bar' ), 'bar', 'writer works' );
    equal( obj.name(), 'bar', 'reader works' );
    equal( obj._name, 'bar', 'raw value is as expected' );

    // writer
    var setAge = o.writer( '_age' );
    var writerCalled = false;
    obj.age = o.accessor('_age', {
        writer: function(){ writerCalled = true; return setAge.apply(this, arguments) },
        devoid: 81
    });
    equal( obj.age(), 81, 'reader returned devoid' );
    ok( writerCalled, 'writer was called to write the devoid' );
    writerCalled = false;
    obj.age( 90 );
    ok( writerCalled, 'writer was called to write' );
});

test( 'core: predicate', function () {
    var obj = { hasName: o.predicate('name') };
    ok( !obj.hasName(), 'returns false when the property is not set' );
    obj.__proto__ = { name: 'Bob' };
    equal( obj.name, 'Bob', 'property is coming from the prototype' );
    ok( !obj.hasName(), 'still not set' );
    obj.name = null;
    ok( obj.hasName(), 'null returns true' );
    obj.name = 'Foo';
    ok( obj.hasName(), 'string returns true' );
    delete obj.name;
    ok( !obj.hasName(), 'not set after deletion' );
});

test( 'core: clearer', function () {
    var obj = { clearName: o.clearer('name') };
    equal(obj.name, undefined, 'undefined before clear');
    obj.name = 'Foo';
    equal(obj.name, 'Foo', 'value is now defined');
    obj.clearName();
    equal(obj.name, undefined, 'value was cleared');

    obj.__proto__ = { name: 'Bar' };
    equal(obj.name, 'Bar', 'value is from the prototype');
    obj.name = 'Baz';
    equal(obj.name, 'Baz', 'direct value overrode prototype value');
    obj.clearName();
    equal(obj.name, 'Bar', 'value is from the prototype after clearer');
});

test( 'core: proxy', function () {
    var obj = {};
    obj.queue = [];
    obj.enqueue = o.proxy('queue', 'unshift');
    obj.dequeue = o.proxy('queue', 'pop');
    deepEqual( obj.queue, [], 'queue is empty' );
    obj.enqueue( 'job1' );
    obj.enqueue( 'job2' );
    obj.enqueue( 'job3' );
    deepEqual( obj.queue, ['job3', 'job2', 'job1'], 'queue is full' );
    equal( obj.dequeue(), 'job1', 'dequeued first job' );
    deepEqual( obj.queue, ['job3', 'job2'], 'remaining jobs are correct' );
});

test( 'core: before', function () {
    var obj = {};
    obj.addNumbers = function (num1, num2) { return num1 + num2 };
    equal( obj.addNumbers(1,2), 3, 'original function works' );
    var beforeCalled = false;
    obj.addNumbers = o.before( obj.addNumbers, function () { beforeCalled = true } );
    equal( obj.addNumbers(1,2), 3, 'modified function still works' );
    ok( beforeCalled, 'the before function was called' );
});

test( 'core: after', function () {
    var obj = {};
    obj.addNumbers = function (num1, num2) { return num1 + num2 };
    equal( obj.addNumbers(1,2), 3, 'original function works' );
    var afterCalled = false;
    obj.addNumbers = o.after( obj.addNumbers, function () { afterCalled = true } );
    equal( obj.addNumbers(1,2), 3, 'modified function still works' );
    ok( afterCalled, 'the after function was called' );
});

test( 'core: around', function () {
    var obj = {};
    obj.addNumbers = function (num1, num2) { return num1 + num2 };
    equal( obj.addNumbers(1,2), 3, 'original function works' );
    obj.addNumbers = o.around(
        obj.addNumbers,
        function (original, num1, num2) {
            if (typeof num1 !== 'number') return null;
            if (typeof num2 !== 'number') return null;
            return original( num1, num2 );
        }
    );

    equal( obj.addNumbers(1,2), 3, 'still works right with around' );
    equal( obj.addNumbers('1', 2), null, 'arround function intercepted non-number' );
});

test( 'core: construct', function () {
    var Point = o.construct(
        function (x, y) { this.x=x; this.y=y },
        {
            getX: function () { return this.x },
            getY: function () { return this.y },
        }
    );
    var p = new Point( 12, 4 );
    deepEqual( [p.getX(), p.getY()], [12, 4], 'basics' );
});

test( 'core: augment', function () {
    var Parent = function (foo) { this.foo = foo };
    Parent.prototype = { getFoo: function () { return this.foo } };

    var Child = o.augment(
        Parent,
        function (parent, foo, bar) { parent(foo); this.bar = bar }
    );
    Child.prototype.getBar = function () { return this.bar };

    var obj = new Child( 'FOO', 'BAR' );
    equal( obj.foo, 'FOO', 'constructor arguments for parent made it through' );
    equal( obj.bar, 'BAR', 'constructor arguments for child made it through' );

    equal( obj.__proto__, Child.prototype, 'objects prototype came from the child constructor' );
    equal( Child.prototype.__proto__, Parent.prototype, 'childs prototype came from the parent constructor' );

    ok( obj instanceof Child, 'object is an instance of the child constructor' );
    ok( obj instanceof Parent, 'object is an instance of the parent constructor' );

    equal( obj.getFoo(), 'FOO', 'called function from the parent' );
    equal( obj.getBar(), 'BAR', 'called function from the child' );

    var Child2 = o.augment(
        Parent,
        function (parent, foo, baz) { parent(foo); this.baz = baz },
        { getBaz: function () { return this.baz } }
    );
    var obj2 = new Child2( 'FOO', 'BAZ' );
    equal( obj2.getBaz(), 'BAZ', 'prototype argument was copied' );

    var Child3 = function (parent, foo, zap, mez) { parent(foo); this.zap = zap; this.mez = mez };
    Child3.prototype.getZap = function () { return this.zap };
    Child3 = o.augment(
        Parent,
        Child3,
        { getMez: function () { return this.mez } }
    );
    var obj3 = new Child3( 'FOO', 'ZAP', 'MEZ' );
    equal( obj3.getZap(), 'ZAP', 'prototype property was copied' );
    equal( obj3.getMez(), 'MEZ', 'constructor prototype was copied' );
});

test( 'core: merge', function () {
    var obj1 = { a:'A', b:'B' };
    var obj2 = { b:'BB', c:'CC', d:'DD' };
    var obj3 = { d:'DDD', e:'EEE' };

    var obj4 = o.merge( obj1, obj2, obj3 );
    equal( obj4, obj1, 'first argument was modified in place' );
    deepEqual( obj1, {a:'A', b:'BB', c:'CC', d:'DDD', e:'EEE' }, 'merged in right order' );
});

test( 'core: clone', function () {
    var A = function (foo) { this.foo = foo };
    A.prototype = { bar: 'BAR' };

    var a = new A( 'FOO' );
    var b = o.clone( a );

    deepEqual( a.foo, b.foo, 'objects match' );
    deepEqual( a.bar, b.bar, 'objects match' );
    equal( a.__proto__, b.__proto__, 'prototype matches' );
    equal( a.constructor, b.constructor, 'constructor matches' );
});

test( 'core: has', function () {
    var obj = { name: 'Foo' };
    ok( o.has(obj, 'name'), 'has found a property' );
    ok( !o.has(obj, 'bah'), 'has did not find a property' );
    obj.__proto__ = { age: 65 };
    equal( obj.age, 65, 'value propogates from prototype' );
    ok( !o.has(obj, 'age'), 'prototype property does not affect has' );
});

test( 'core: noConflict', function () {
    equal(oJS, o, 'oJS is exported');
    var oldO = o;
    var newO = o.noConflict();
    equal(o, 'ORIGINAL_O', 'originl value of o was set');
    equal(oldO, oJS, 'returned o');
    o = oldO;
});

test( 'types: basic', function () {
    var undef; var obj = { foo: 32 };

    var values = [
        undefined,           // 0
        null,
        true,
        false,
        new Boolean(false),
        'string',            // 5
        new String('String'),
        '',
        123,
        new Number(456),
        9.876,               // 10
        -123,
        0,
        function () {},
        new Function ('foo', 'console.log(foo)'),
        {},                  // 15
        new Object({}),
        [],
        new Array([]),
        /a+b/,
        new RegExp('b+a'),   // 20
        new Date()
    ];

    var tests = [
        [ 'undefined', 0 ],
        [ 'defined', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 ],
        [ 'null', 1 ],
        [ 'boolean', 2, 3, 4 ],
        [ 'string', 5, 6, 7 ],
        [ 'number', 8, 9, 10, 11, 12 ],
        [ 'integer', 8, 9, 11, 12 ],
        [ 'positive', 8, 9, 10 ],
        [ 'negative', 11 ],
        [ 'nonZero', 8, 9, 10, 11 ],
        [ 'function', 13, 14 ],
        [ 'object', 4, 6, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21 ],
        [ 'array', 17, 18 ],
        [ 'regExp', 19, 20 ],
        [ 'date', 21 ]
    ];

    for (var i = 0, l = tests.length; i < l; i++) {
        var okValues = tests[i];
        var type = okValues.shift();
        var is = o[type + 'Type']();

        var okLookup = {};
        for (var j = 0, m = okValues.length; j < m; j++) {
            okLookup[ okValues[j] ] = true;
        }

        for (var j = 0, m = values.length; j < m; j++) {
            var value = values[j];
            if (okLookup[j]) { ok( is(value), '' + value + ' is ' + type ) }
            else { ok( !is(value), '' + value + ' is not ' + type ) }
        }
    }
});

test( 'types: enum', function () {
    ok( o.isEnum('bar', ['foo', 'bar', 'baz']), 'is' );
    ok( !o.isEnum(5, [1, 2, 3]), 'isnt' );

    var type = o.enumType(['this', 'that', 'other']);
    ok( type('other'), 'is via type' );
    ok( !type('them'), 'isnt via type' );
});

test( 'types: instanceof', function () {
    var Parent = function () { };

    var Child = o.augment(
        Parent,
        function (parent) { parent() }
    );

    var child = new Child();

    var type = o.instanceOfType(Array);
    ok( type(new Array()), 'new Array instanceOf Array' );
    ok( !type(child), 'child doesnot instanceOf Array' );

    type = o.instanceOfType(Parent);
    ok( type(child), 'Child instanceOf Parent' );
});

test( 'types: duck', function () {
    var obj = { foo: 1, bar:2 };

    ok( o.isDuck(obj, ['foo', 'bar']), 'all good' );
    ok( o.isDuck(obj, ['foo']), 'one good' );
    ok( !o.isDuck(obj, ['baz', 'foo']), 'one good, one bad' );
    ok( !o.isDuck(obj, ['baz']), 'one bad' );
});

test( 'types: any', function () {
    var any = o.anyType([ o.stringType(), o.nullType() ]);

    ok( any('str'), 'string is a string or null' );
    ok( any(null), 'null is a string or null' );
    ok( !any(123), 'number if not a string and is not null' );
});

test( 'types: all', function () {
    var all = o.allType([ o.integerType(), o.positiveType() ]);

    ok( all(1), '1 is an integer and is positive' );
    ok( !all(0), '0 is not an integer or is not positive' );
    ok( !all(-1), '-1 is not an integer or is not positive' );
    ok( !all(1.23), '1.23 is not an integer or is not positive' );
});

test( 'types: none', function () {
    var none = o.noneType([ o.integerType(), o.positiveType() ]);

    ok( !none(1), '1 is an integer and is positive' );
    ok( !none(0), '0 is an integer or is not positive' );
    ok( !none(-1), '-1 is an integer or is not positive' );
    ok( none(-1.23), '-1.23 is not an integer and is not positive' );
});

test( 'types: not', function () {
    var not = o.notType( o.stringType() );

    ok( not(123), '123 is not a string' );
    ok( !not('abc'), 'abc is a string' );
});

test( 'attribute', function () {
    var ageAttr = new o.Attribute({
        key: 'age',
        type: o.positiveType(),
        devoid: function () { return 18 },
        clearer: true
    });

    var nameAttr = new o.Attribute({
        key: 'name',
        type: o.nonEmptyStringType(),
        required: true,
        writer: '_setName',
        predicate: true
    });

    var obj = {};
    ageAttr.apply( obj );
    nameAttr.apply( obj );

    equal( obj.age(), 18, 'devoid was applied' );
    obj.age( 32 );
    equal( obj.age(), 32, 'age was set' );

    obj.clearAge();
    equal( obj.age(), 18, 'devoid was re-applied after clear' );

    equal( obj.hasAge, undefined, 'no predicate was created' );

    equal( obj.hasName(), false, 'predicate was created' );
    throws( function(){ obj.name() }, 'throws when required' );
    obj._setName('Foo');
    equal( obj.name(), 'Foo', 'name was set' );
    obj.name('Bar');
    equal( obj.name(), 'Foo', 'name was set by reader' );
    equal( obj.clearName, undefined, 'no clearer was created' );
});
</script>

    </body>
</html>
