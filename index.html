<!DOCTYPE html>
<html>
    <head>
        <title>o.js - Javascript utility belt for rich objects and prototypes. Ooooh!</title>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">

        <style>
            body {
                background-color: #fff;
                color: #000;
                margin: 0px;
                padding: 40px;
                font-family: sans-serif;
                font-size: 17px;
            }

            div.page {
                max-width: 900px;
                margin: 0px auto;
            }

            p, pre, ul, h4 {
                margin-top: 12px;
                margin-bottom: 12px;
            }

            h1 {
                color: #0776BA;
                font-size: 64px;
                font-weight: bold;
                margin: 32px 0px 24px 0px;
            }

            h1:first-child {
                margin-top: 0px;
            }

            h2 {
                margin: 48px 0px 16px 0px;
                background-color: #eee;
                padding: 4px;
            }

            h3 {
                margin: 36px 0px 16px 0px;
                border-bottom: solid 1px #ccc;
            }

            h4 {
                font-family: monospace;
                font-style: italic;
                font-size: 20px;
                font-weight: normal;
                color: #76ABCC;
            }

            pre {
                border: dashed 2px #ddd;
                padding: 16px;
                color: #777;
            }

            a {
                text-decoration: none;
                color: #007DC9;
            }

            a:hover {
                text-decoration: underline;
            }

            ul ul {
                margin-top: 0px;
                margin-bottom: 0px;
            }

            div.copyright {
                text-align: right;
                margin-top: 64px;
            }
        </style>
    </head>
    <body><div class="page">


<h1>o.js</h1>

<p>
Javascript utility belt for rich objects and prototypes.  Ooooh!
</p>

<ul>
    <li><a href="#Synopsis">Synopsis</a></li>
    <li><a href="#Description">Description</a></li>

    <li><a href="#Properties">Properties</a></li>
    <!-- <ul>
        <li><a href="#Properties-reader">reader</a></li>
        <li><a href="#Properties-writer">writer</a></li>
        <li><a href="#Properties-accessor">accessor</a></li>
        <li><a href="#Properties-predicate">predicate</a></li>
        <li><a href="#Properties-clearer">clearer</a></li>
    </ul> -->

    <li><a href="#PropertyDefinition">Property Definition</a></li>
    <!-- <ul>
        <li><a href="#PropertyDefinition-isa">isa</a></li>
        <li><a href="#PropertyDefinition-coerce">coerce</a></li>
        <li><a href="#PropertyDefinition-default">default</a></li>
        <li><a href="#PropertyDefinition-required">required</a></li>
        <li><a href="#PropertyDefinition-chain">chain</a></li>
        <li><a href="#PropertyDefinition-option">option</a></li>
        <li><a href="#PropertyDefinition-reader">reader</a></li>
        <li><a href="#PropertyDefinition-writer">writer</a></li>
        <li><a href="#PropertyDefinition-predicate">predicate</a></li>
    </ul> -->

    <li><a href="#Methods">Methods</a></li>
    <!-- <ul>
        <li><a href="#Methods-before">before</a></li>
        <li><a href="#Methods-after">after</a></li>
        <li><a href="#Methods-around">around</a></li>
        <li><a href="#Methods-chain">chain</a></li>
    </ul> -->

    <li><a href="#Constructors">Constructors</a></li>
    <!-- <ul>
        <li><a href="#Constructors-extend">extend</a></li>
    </ul> -->

    <li><a href="#Utilities">Utilities</a></li>
    <!-- <ul>
        <li><a href="#Utilities-noConflict">noConflict</a></li>
    </ul> -->

    <li><a href="#Support">Support</a></li>
    <li><a href="#Contributing">Contributing</a></li>
    <li><a href="#Legal">Legal</a></li>
</ul>


<h2><a name="Synopsis"></a>Synopsis</h2>

<pre><code>var obj = {
    getName: o.reader('name'),
    setName: o.writer('name'),
    hasName: o.predicate('name'),
    clearName: o.clearer('name'),
    age: o.accessor('_age')
};

obj.setName('Tiberius');
if (obj.hasName()) console.log( obj.getName() );
obj.clearName();

obj.age( 23 );
console.log( obj.age() );
</code></pre>


<h2><a name="Description"></a>Description</h2>

<p>
This library provides utilities for building rich objects and prototypes.  The
interface is meant to be simple and flexible.  No framework is provided, instead
a toolbelt full of utilities is provided to make this happen.  This way you
can use this library the way you see fit.
</p>

<p>
<strong>WARNING:</strong> This library is very new and the API will change
as I gather feedback!
</p>


<h2><a name="Properties"></a>Properties</h2>


<h3><a name="Properties-reader"></a>reader</h3>

<h4>o.reader( key, [definition] )</h4>
<p>
Creates a reader function that will return the value of the key.
</p>
<pre><code>var obj = {
    getName: o.reader('name'),
    name: 'Jessica'
};

console.log( obj.getName() ); // Jessica
</code></pre>

<h3><a name="Properties-writer"></a>writer</h3>

<h4>o.writer( key, [definition] )</h4>
<p>
Creates a function that will write the passed in value to the key.
</p>
<pre><code>var obj = {
    setName: o.writer('name')
};

obj.setName('Jessica');
console.log( obj.name ); // Jessica
</code></pre>


<h3><a name="Properties-accessor"></a>accessor</h3>

<h4>o.accessor( key, [definition] )</h4>
<p>
This creates a function that will always return the value of the key,
like <code>reader</code>, but will also write if a value is passed
like a <code>writer</code>.
</p>
<pre><code>var obj = {
    name: o.accessor('_name')
};

obj.name('Jessica');
console.log( obj.name() ); // Jessica
</code></pre>


<h3><a name="Properties-predicate"></a>predicate</h3>

<h4>o.predicate( key )</h4>
<p>
Creates a a function that will return true if the property has been
set.
</p>
<pre><code>var obj = {
    hasName: o.predicate('name')
};

console.log( obj.hasName() ); // false
obj.name = 'Jessica';
console.log( obj.hasName() ); // true
</code></pre>


<h3><a name="Properties-clearer"></a>clearer</h3>

<h4>o.clearer( key )</h4>
<p>
Creates a function that will clear the key.
</p>
<pre><code>var obj = {
    clearName: o.clearer('name'),
    name: 'Jessica'
};

console.log( obj.name ); // Jessica
obj.clearName();
console.log( obj.name() ); // undefined
</code></pre>


<h2><a name="PropertyDefinition"></a>Property Definition</h2>

<p>
Properties have definitions which describe how the property should behave.
A definition is just an object containing flags and value.  Not all property
functions handle all definitions.
</p>


<h3><a name="PropertyDefinition-isa"></a>isa</h3>

<h4>definition.isa = type</h4>
<p>
Before writing, checks to see if the value is of the specified type.  Types
can be anything that <code>typeof</code> could return.
</p>

<h4>definition.isa = constructor</h4>
<p>
If a constructor function is passed and the value is an object, then this
checks to see if the constructor appears in the object's prototype chain
(via <code>instanceof</code>).
</p>

<h4>definition.isa = function (value) { ... }</h4>
<p>
Finally, if a function is given then the function will be called with the
value as a single argument.  The return value of the function must be
<code>true</code> for the isa check to pass.
</p>


<h3><a name="PropertyDefinition-coerce"></a>coerce</h3>

<h4>definition.coerce = function (value) { ... }</h4>
<p>
Before a value is written the coercion function will be called with the
value being set.  The value that the coercion function returns will be
written instead.  The coercion function is called before the <code>isa</code>
check.
</p>


<h3><a name="PropertyDefinition-default"></a>default</h3>

<h4>definition.default = value</h4>
<p>
When the reader is called this value will be used to write a default
if no value is currently set.
</p>

<h4>definition.default = function () { ... }</h4>
<p>
If the value if the default is a function then that function will be
called and the return value will be used.  If you would like the default
value itself to be a function then you'll need to make your default be
a function that returns a function, as in:
</p>
<pre><code>var obj = {
    getFoo: o.reader(
        'foo',
        {
            default: function () {
                return function () { ... };
            }
        }
    )
};

console.log( typeof obj.getName() ); // function
</code></pre>


<h3><a name="PropertyDefinition-required"></a>required</h3>

<h4>definition.required = boolean</h4>
<p>
If set to <code>true</code> this will cause the <code>reader</code> to
throw an error if the value for the key has not been set.
</p>


<h3><a name="PropertyDefinition-chain"></a>chain</h3>

<h4>definition.chain = boolean</h4>
<p>
If set to <code>true</code> this will cause the <code>writer</code> to
return the object rather than the value so that you can chain writers
together, as in:
</p>
<pre><code>var obj = {
    name: o.writer('_name', {<strong>chain:true,</strong> isa:'string'}),
    age:  o.writer('_age',  {<strong>chain:true,</strong> isa:'number'})
};

obj.name('Bob').age(56);
</code></pre>


<h3><a name="PropertyDefinition-option"></a>option</h3>

<h4>definition.option = boolean</h4>
<p>
When set to <code>true</code>, this causes the <code>writer</code>
to default the value to <code>true</code> if the value is undefined, and then
returns the object rather than the value, much like <code>chain</code> does.
This is useful for creating simple boolean properties that can be chained
together.  For example:
</p>
<pre><code>var def = {
    <strong>option:  true,</strong>
    isa:     'boolean',
    default: false
};

var obj = {
    lazy:         o.writer('_lazy',      def),
    impatient:    o.writer('_impatient', def),
    hubris:       o.writer('_hubris',    def),
};

obj.lazy().impatient();
obj.lazy(false).hubris();

console.log( obj._lazy      ); // false
console.log( obj._impatient ); // true
console.log( obj._hubris    ); // true
</code></pre>


<h3><a name="PropertyDefinition-reader"></a>reader</h3>

<h4>definition.reader = o.reader(...)</h4>
<p>
When <a href="#Properties-accessor">o.accessor</a> is reading it needs a
reader method to call.  If one is not supplied then one will be built using
the supplied definition.  But, this can be overriden by specifying your own.
</p>
<pre><code>var nameReader = o.reader('_name');
var obj = {
    name: o.accessor('_name', { reader: nameReader })
};
</code></pre>


<h3><a name="PropertyDefinition-writer"></a>writer</h3>
<p>
This is just like <a href="PropertyDefinition-reader">definition.reader</a>,
except it is for the writer function and is used by both
<a href="#Properties-accessor">o.accessor</a>, and
<a href="#Properties-reader">o.reader</a> (when writing a default value).
</p>


<h3><a name="PropertyDefinition-predicate"></a>predicate</h3>
<p>
This is just like <a href="PropertyDefinition-reader">definition.reader</a>,
except it is for the predicate function and is used by
<a href="#Properties-reader">o.reader</a> (to check if a value has been
written).
</p>


<h2><a name="Methods"></a>Methods</h2>


<h3><a name="Methods-before"></a>before</h3>

<h4>o.before( originalFunc, beforeFunc )</h4>
<p>
Creates a new function that calls your <code>beforeFunc</code> before calling
the original <code>originalFunc</code>.  The return value will be whatever
<code>originalFunc</code> returned.  The <code>beforeFunc</code> will not be
passed any arguments.  If you'd like to also intercept the <code>originalFunc</code>'s
arguments then you'll need to use <a href="#Methods-around">o.around</a>.
</p>
<pre><code>var obj = {
    foo = function (str) { console.log(str) }
};

obj.foo = o.before( obj.foo, function () { console.log('Before!') } );

obj.foo('Original!');
// Before!
// Original!
</code></pre>
<p>
This is useful for adding functionality to a method without changing the way it
behaves.
</p>

<h3><a name="Methods-after"></a>after</h3>

<h4>o.after( originalFunc, afterFunc )</h4>
<p>
This works just like <a href="#Methods-before">o.before</a>, but calls the
<code>afterFunc</code> after calling <code>originalFunc</code>.

<h3><a name="Methods-around"></a>around</h3>

<h4>o.around( originalFunc, aroundFunc )</h4>
<p>
This is a hybrid of <a href="#Methods-before">o.before</a> and
<a href="#Methods-after">o.after</a> that let's you intercept and
change the arguments and even decide to not call the underlying
<code>originalFunc</code> if you choose not to.
</p>
<pre><code>var obj = {
    addNums: funcion (num1, num2) { return num1 + num2 }
};

obj.addNums = o.around(
    obj.addNums,
    funcion (original, num1, num2) {
        if (typeof num1 !== 'number') return null;
        if (typeof num2 !== 'number') return null;
        return original( num1, num2 );
    }
);

console.log( obj.addNums(1,2) ); // 3
console.log( obj.addNums('abs',2) ); // null
</code></pre>


<h3><a name="Methods-chain"></a>chain</h3>

<h4>o.chain( originalFunc )</h4>
<p>
Makes a method chainable by throwing away the return value and returning
the object instead.
</p>
<pre><code>var obj = {
    bar: function (str) { this.barValue=str; return str }
};

console.log( obj.bar('Testing') ); // Testing
obj.bar = o.chain( obj.bar );
console.log( obj.bar('Testing') ); // obj
</code></pre>


<h2><a name="Constructors"></a>Constructors</h2>


<h3><a name="Constructors-extend"></a>extend</h3>

<h4>o.extend( parent, constructor )</h4>
<p>
Extends the given <code>constructor</code> function with
the given <code>parent</code> function. This is much more advanced than
your typical extend function that exists in other libraries as it works
at the constructor level rather than the object level.
</p>
<p>
How this works is two parts.  First, <a href="#Methods-around">o.around</a>
is used where <code>parent</code> is the <code>originalFunc</code> and
<code>constructor</code> is the <code>aroundFunc</code>.  Second, the
prototype of the <code>parent</code> is merged with the prototype of the
<code>constructor</code> and used as the prototype for the new constructor
that is returned.  An example is worth a 1,000 words:
</p>
<code><pre>var Parent = function (foo) {
    this.foo = foo;
};
Parent.prototype = {
    logFoo: function () { console.log( this.foo ) }
};

var Child = function (parent, foo, bar) {
    this.bar = bar;
    parent(foo);
};
Child.prototype = {
    logBar: function () { console.log( this.bar ) }
};

Child = o.extend( Parent, Child );

var obj = new Child( 'FOO', 'BAR' );

obj.logFoo(); // FOO
obj.logBar(); // BAR
</code></pre>


<h2><a name="Utilities"></a>Utilities</h2>


<h3><a name="Utilities-noConflict"></a>noConflict</h3>

<h4>o.noConflict()</h4>
<p>
When <code>o.js</code> is first loaded it will export the <code>o</code>
object into the root namespace (<code>window</code> in a browser, or
<code>global</code> in Node.js).  For some people this can be problematic
as the <code>o</code> variable may already be in use.
</p>
<p>
When <code>o.noConflict</code> is called the original value of <code>o</code>
in the root namespace will be set, and the current <code>o</code> will be returned.
</p>
<pre><code>&lt;script>var o = 'Hello World';&lt;/script>
&lt;script src="o.js">&lt;/script>
&lt;script>
    var oJS = o.noConflict();
    // Now use oJS. onstead of o.
    console.log( o ); // 'Hello World'
&lt;/script>
</code></pre>


<h2><a name="Support"></a>Support</h2>

<p>
Currently the best avenue of support is by submitting issue reports and feature requests
on our <a href="https://github.com/bluefeet/o-js/issues">GitHub Issue Tracker</a>.</li>
</p>

<h2><a name="Contributing"></a>Contributing</h2>

<p>
Would you like to contribute?  Then <a href="https://github.com/bluefeet/o-js">fork
our respository on GitHub</a> and send a pull request.
</p>


<h2><a name="Legal"></a>Legal</h2>

<p>&copy; Aran Deltac</p>
<p>o.js may be freely distributed under the MIT license.</p>

    </div></body>
</html>
